#!/bin/bash
# Example of an enirely new sub-command

# Help
usage="commit-merge: Commit the files and directories in a path and merge those changes
to other checkouts and commit them there too.

Valid options:
  -m                       : message
  -c                       : a changeset number to use when merging instead of commiting
  -u                       : update checkouts before commiting and merging
  
Example:
  svn commit-merge -m \"foo bar\" app/templates [../staging.last.fm[, ../i18.last.fm]]
"

if [ -z $1 ]; then
    echo "$usage" && exit 1
fi

# Defaults
message=""
changeset=""

# Options and arguments
while getopts ":m:c:u" opt; do
    case $opt in
            m ) message=$OPTARG ;;
            c ) changeset=$OPTARG ;;
            u ) update=true ;;
            h | \? ) echo "$usage" && exit 1 ;;
    esac
done

shift $(($OPTIND - 1))

# Grab the path we're commiting
path=$1 && shift

if [ ! -n "$changeset" ]; then
    
    # Update the commit path first?
    if [ $update ]; then
        echo "svn update $path"
    fi
    
    svn_commit="/Users/user/command-adaptor/svn/ci-mock" # Debug mock
    
    # Commit, grab the output (This is messy, can it just be done once?)
    if [ -n "$message" ]; then
        commit=$($svn_commit $path -m "$message")
    else
        commit=$($svn_commit $path)
    fi
    
    echo $commit
    
    # Check last exit for failure and abort
    if [ $? -gt 0 ]; then
        exit $? # Let the svn error speak for itself
    fi

    # Extract the changeset (nicer way to do this?)
    changeset=$(echo $commit | sed -e 's/.* \([0-9]*\)*\.$/\1/') 
fi

# Do merges
for checkout do
    if [ $update ]; then
        echo "svn update $checkout/$path"
    fi
    echo "Merging [$changeset] to $checkout/$path"
done